from google.cloud import storage
import cv2
import numpy as np
import os
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense

# Definieer het aantal klassen
NUM_CLASSES = 5

# Verbind met de Google Cloud Storage-client
def download_blob(bucket_name, source_blob_name, destination_file_name):
    """Downloads a blob from the bucket."""
    storage_client = storage.Client()
    bucket = storage_client.bucket(bucket_name)
    blob = bucket.blob(source_blob_name)
    blob.download_to_filename(destination_file_name)
    print(f'Blob {source_blob_name} gedownload naar {destination_file_name}.')

# Lijst van bestanden in de bucket
bucket_name = 'datasetmeters'
prefix = 'path/to/images/'  # Prefix voor de bestandsnamen in de bucket
storage_client = storage.Client()
bucket = storage_client.get_bucket(bucket_name)
blobs = bucket.list_blobs(prefix=prefix)
image_urls = [f"https://storage.googleapis.com/{bucket_name}/{blob.name}" for blob in blobs]

# Laad de afbeeldingen vanuit Google Cloud Storage en voer de gewenste bewerkingen uit
images = []
labels = []  # Voeg labels toe aan je dataset
for url in image_urls:
    # Download de afbeelding naar een tijdelijk bestand
    temp_file = 'temp.jpg'
    download_blob(bucket_name, url[len("https://storage.googleapis.com/" + bucket_name + "/"):], temp_file)

    # Lees de afbeelding in met OpenCV
    image = cv2.imread(temp_file)

    if image is not None:
        # Voeg je preprocessing en labeling hier toe
        images.append(image)
        labels.append(0)  # Pas dit aan naar de juiste label

    # Verwijder het tijdelijke bestand
    os.remove(temp_file)

# Controleer of er afbeeldingen zijn geladen
if len(images) == 0:
    raise ValueError("Geen afbeeldingen geladen. Controleer of de bestandsnamen en paden correct zijn.")

# Converteer lijsten naar numpy arrays
images = np.array(images)
labels = np.array(labels)

# Controleer de vorm van de images array
print(f"Shape van images array: {images.shape}")

# Bouw het model
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(images.shape[1], images.shape[2], images.shape[3])),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(NUM_CLASSES, activation='softmax')
])

# Compileer het model
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train het model
model.fit(images, labels, epochs=10)

# Sla het model op
model.save('saved_model')
